
Shell Grammar
=============

   SimpleCommand ::= “a space separated sequence of words and
                      redirections”

   Pipeline ::= “a sequence of one or more commands, separated by `|`”

   List ::= “A list is a sequence of one or more pipelines separated
             by one of the operators `;`, `&`, `&&`, or `||`, or
             newline.”


First part:

    cmd1 arg1 arg2 >redir1 | cmd2 <(cmd3 2>redir2 | cmd4) 2>&1 >redir2
    ^^^^^^^^^^^^^^^^^^^^^^
             |
         we will first talk
        about this part only

  * Command invocation,

  * command line arguments, and globbing

  * and redirection to/from files.

Future parts:

  * pipelines

  * subshells

  * ...


Simple commands
===============

    $ echo hello shell

  * The shell splits your input into words.

  * The first word specifies the command to be executed.

  * The remaining words are passed as arguments to the invoked command.

Types of commands (the first word)

    $ type echo
    echo is a shell builtin           # a builtin

    $ type xterm
    xterm is /usr/bin/xterm           # a real program

Builtin commands should behave almost as “real programs” do, but the
functionality is implemented in the shell, and does usually not invoke
a new process.


Command line arguments
----------------------

How are command line arguments passed to a program?

    $ e arg.c

    $ ./arg

    $ ./arg hello world
    $ ./arg "hello world"

Quoting:

    $ ./arg hel"lo wor"ld

  * There's no concept like string literals!

FIXME: more on that

  * Globbing: Who resolves `*.c`, and what about `shopt failglob`

        $ ./arg *.c
        $ echo *.c
        $ ls *.c
        $ echo *.c noSuchFile
        $ ls *.c noSuchFile

  * Quoting: `\…`, `'…'`, `"…"`, `$'…'`


Running a program
=================

Each process has an ID and a parent process (except for the root,
PID 1).

    $ echo $$         # PID of the shell  (but: see below)

    $ e pid.c

    $ ./pid
    $ ./pid

Both `pid`-processes have individual PIDs, and the shell's PID as
PPID.


Execute: Replace one program with another
-----------------------------------------

    $ man 2 execve
    $ man 3 exec           # family of frontend functions

    $ e exec.c

    $ ./exec arg abc 123

    $ ./exec pid

So the program `exec`-process is actually the programm `pid`.  We
cannot do anything in our program behind the `execve`, unless `execve`
fails.  That's quite limiting.

Note: The shell has an `exec` builtin, which replaces the shell with
      another program.

    $ type exec
    $ help exec         # `help` works for every builtin command

    $ echo $$
    $ ./pid 10
    $ exec ./pid 10

Use this to your advantage: When the shell script's last job is to
launch another program, use `exec` to get rid of the shell itself.


Fork a child process
--------------------

    $ man 2 fork

    $ e fork.c

    $ fork.c

Calling `fork` returns twice,

  * once in the new child process with return value 0, and

  * once in the original process, the parent, returning the child's
    PID.


Fork a child, then replace it
-----------------------------

    $ e background.c

    $ /usr/bin/xterm
    $ ./background /usr/bin/xterm

    $ ./background pid

  * PPID==1 indicates an orphan:  The parent process has died.

  * wait for your child

    $ man 2 wait
    $ ./background pid sleep


Redirection
===========

    $ ls *.c noSuchFile

    $ ls *.c noSuchFile >file1    # ≡ `1>file1`
    $ cat file1

    $ ls *.c noSuchFile 2>file2
    $ cat file2

What about `3>file3`?

    $ man 1 strace

    $ strace ./arg   # observe mix of syscalls and output

    $ strace ./arg 2>strace.log       # yes, I know about `-o`

    write(1, "     0: ./arg\n", 14)         = 14
          ^
          man 2 write

Try to write to file descriptor 2:

    $ man 2 write

    $ e write.c

    $ ./write
    $ ./write >file1
    $ ./write 2>file2

Edit `write.c` to write to file descriptor 5.  Then

    $ ./write
    $ ./write 5>file5

So somehow the file `file5` was opened for writing, and the file
descriptor 5 was made available to the newly run program.

How does the shell do that?


Open a file by name
-------------------

    $ man 2 open

    $ e open.c

    $ ./open
    $ cat output


Open file descriptors are shared on forking
-------------------------------------------

    $ e sharedfd.c

    $ ./sharedfd
    $ cat output

Also: Demonstrate a race condition by repeating each write 100 times.


Make sure a file is opened with FD 2
------------------------------------

We cannot do this, but we can reassign an open file descriptor to
another one:

    $ man 2 dup2

    $ e dup2.c

    $ ./dup2
    $ cat output

So the redirection `… n>file` involves two steps:

    fd = open("file", …)
    dup2(fd, n);


Re-use a file-descriptor
------------------------

It is generally wrong to redirect stderr and stdout to the same file:

    $ ls -l arg.c mdlbrmft >file1 2>file1
    $ cat file1

And we can explain why:

    $ e conflict.c
    $ ./conflict
    $ cat output

Correct:

    $ ls -l arg.c mdlbrmft >file1 2>&1
    $ cat file1


So, if the shell sees a `2>&1`, it simply does a `dup2(1, 2)`.

With this, we can understand why the order of redirections is
significant.  The shell just parses and applies the redirections from
left to right:

    $ ls -l arg.c mdlbrmft >file1 2>&1
    $ cat file1

    // 1>file
    fd = open("file1", …)  // `write(fd, …)` goes to `file1`
    dup2(fd, 1)            // `write(1, …)` goes to where `write(fd, …)` goes

    // 2>&1
    dup2(1, 2)            // `write(2, …)` goes to where `write(1, …)` goes,
                             which is now where `write(fd, …)` goes

The other way round:

    $ ls -l arg.c mdlbrmft 2>&1 >file1
    $ cat file1

    // 2>&1
    dup2(1, 2)            // `write(2, …)` goes to where `write(1, …)` goes,
                             which is stdout.

    // 1>file
    fd = open("file1", …)  // `write(fd, …)` goes to `file1`
    dup2(fd, 1)            // `write(1, …)` goes to where `write(fd, …)` goes



Run program with redirection to file
====================================

    fork a child process
    if child:
        open output file
        make 1 an alias for its file descriptor
        replace yourself with the program to run

Demo:

    $ e redirect.c

    $ ./redirect /usr/bin/ls -l arg.c mdlbrmft
    parent stdout still working
    /usr/bin/ls: cannot access 'mdlbrmft': No such file or directory

    $ cat output
    -rw------- 1 klinger klinger 154 Feb 17 17:29 arg.c


______________________________________________________________________
TODO

based on this, explain order of redirections, and 2>&1
